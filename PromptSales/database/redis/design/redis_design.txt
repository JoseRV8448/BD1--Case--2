# Diseño de Base de Datos Redis Cache para PromptSales
# Versión: 2.0 - Revisado según requisitos del profesor
# Fecha: 2025-10-22

# ========================================
# DECISIONES DE DISEÑO
# ========================================
# 1. Propósito: Reducir llamadas a APIs/MCP, minimizar consumo de tokens AI
# 2. Estrategia TTL: Basada en frecuencia de cambio de datos
# 3. Patrón de nombres: {dominio}:{entidad}:{identificador}
# 4. Cumplimiento: Tiempo respuesta < 400ms (requisito no funcional)
# ========================================

# ========================================
# 1. CACHÉ DE RESULTADOS DE LLAMADAS API/MCP
# ========================================
api:resultados:{nombre_servicio}:{metodo}:{hash_parametros}
  Tipo: String (JSON)
  TTL: 3600 (1 hora)
  Valor: {
    "respuesta": {...},
    "marca_tiempo": "2025-10-22T10:30:00Z",
    "contador_accesos": 5,
    "tiempo_respuesta_ms": 245,
    "codigo_estado": 200
  }
  Ejemplo: api:resultados:openai:generateImage:abc123def456

# ========================================
# 2. ESTADÍSTICAS DE LLAMADAS API (NUEVO)
# ========================================
api:stats:{service_name}
  Tipo: Hash
  TTL: 86400 (24 horas)
  Campos:
    - total_calls: 1523
    - successful_calls: 1498
    - failed_calls: 25
    - avg_response_time_ms: 342.5
    - last_error: "timeout_error"
    - last_error_timestamp: "2025-10-22T09:15:00Z"
    - cost_accumulated_usd: 45.67
    - tokens_consumed: 125000
  Ejemplo: api:stats:openai

# ========================================
# 3. CACHÉ DE RESULTADOS PARA AHORRO DE TOKENS AI
# ========================================
ai:generacion:{modelo}:{hash_prompt}
  Tipo: String (JSON)
  TTL: 86400 (24 horas)
  Valor: {
    "resultado": "contenido generado por IA...",
    "tokens_usados": 150,
    "tokens_prompt": 50,
    "tokens_completion": 100,
    "version_modelo": "gpt-4-turbo",
    "marca_tiempo": "2025-10-22T10:30:00Z",
    "costo_usd": 0.003,
    "parametros_usados": {
      "temperature": 0.7,
      "max_tokens": 200
    }
  }
  Ejemplo: ai:generacion:gpt4:hash_abc123

# ========================================
# 4. RESULTADOS DE BÚSQUEDA VECTORIAL (MEJORADO)
# ========================================
contenido:busqueda:{hash_descripcion}
  Tipo: String (JSON)
  TTL: 7200 (2 horas)
  Valor: {
    "resultados": [
      {
        "id_imagen": "ObjectId(507f1f77bcf86cd799439011)",
        "url": "https://cdn.promptcontent.com/img123.jpg",
        "score_similitud": 0.95,
        "hashtags": ["#marketing", "#producto"],
        "categoria": "articulos_deportivos",
        "descripcion_corta": "Persona corriendo..."
      }
    ],
    "parametros_busqueda": {
      "descripcion_original": "persona haciendo ejercicio",
      "categoria_filtro": "articulos_deportivos",
      "limite_resultados": 10
    },
    "total_resultados": 15,
    "tiempo_busqueda_ms": 45,
    "fuente_vectorial": "pinecone",
    "namespace": "promptcontent_images",
    "marca_tiempo": "2025-10-22T10:30:00Z"
  }
  Ejemplo: contenido:busqueda:hash_ejercicio_deportes

# ========================================
# 5. ESTADÍSTICAS DE CAMPAÑAS (PARA DELTAS ETL)
# ========================================
estadisticas:campana:{id_campana}:{tipo_metrica}
  Tipo: Hash
  TTL: 660 (11 minutos - ciclo ETL)
  Campos:
    - ultimas_vistas: 1250
    - ultimos_clics: 45
    - ultimas_impresiones: 3500
    - ultimas_conversiones: 12
    - ultimos_ingresos: 1450.50
    - ultima_actualizacion: "2025-10-22T10:20:00Z"
    - delta_desde_ultimo_etl: true
  Ejemplo: estadisticas:campana:camp_001:engagement

# ========================================
# 6. SEGUIMIENTO TEMPORAL DE DELTAS ETL
# ========================================
etl:delta:{bd_origen}:{nombre_tabla}
  Tipo: String (JSON)
  TTL: 1320 (22 minutos - 2x ciclo ETL)
  Valor: {
    "ultimo_id_procesado": 156789,
    "ultima_marca_tiempo": "2025-10-22T10:09:00Z",
    "registros_procesados": 342,
    "proxima_ejecucion": "2025-10-22T10:20:00Z",
    "estado_ultima_ejecucion": "exitoso",
    "duracion_ms": 2340
  }
  Ejemplo: etl:delta:promptads:campaigns

# ========================================
# 7. CACHÉ DE SESIONES/PERMISOS DE USUARIO
# ========================================
sesion:{id_usuario}
  Tipo: Hash
  TTL: 7200 (2 horas)
  Campos:
    - token_sesion: "jwt_token_here..."
    - permisos: '["read:campaigns", "write:content"]'
    - suscripciones_activas: '["promptads", "promptcrm"]'
    - ultima_actividad: "2025-10-22T10:30:00Z"
    - rol: "admin|usuario|agente_ventas"
    - ip_ultima: "192.168.1.100"
  Ejemplo: sesion:user_123

# ========================================
# 8. ESTADO DE SERVIDORES MCP (MEJORADO)
# ========================================
mcp:servidor:{nombre_servidor}
  Tipo: Hash
  TTL: 300 (5 minutos)
  Campos:
    - estado: "activo"
    - ultima_llamada: "2025-10-22T10:29:00Z"
    - tools_disponibles: '["getContent", "generateCampaignContent"]'
    - llamadas_exitosas_5min: 23
    - llamadas_fallidas_5min: 1
    - latencia_promedio_ms: 850.5
    - version: "1.0.0"
    - health_check_url: "http://mcp-server:3000/health"
  Ejemplo: mcp:servidor:content_generator

# ========================================
# 9. RATE LIMITING (NUEVO)
# ========================================
ratelimit:{service}:{user_id}:{window}
  Tipo: String (contador)
  TTL: 60 (1 minuto) o 3600 (1 hora) según ventana
  Valor: "45" (número de requests en ventana actual)
  Ejemplo: ratelimit:openai:user_123:minute

ratelimit:global:{service}:{window}
  Tipo: String (contador)
  TTL: 60 (1 minuto)
  Valor: "2345" (requests totales en ventana)
  Ejemplo: ratelimit:global:openai:minute

# ========================================
# 10. CONSUMO DE TOKENS AI POR USUARIO (NUEVO)
# ========================================
ai:tokens:{user_id}:{year}-{month}
  Tipo: Hash
  TTL: 2592000 (30 días)
  Campos:
    - tokens_usados: 45000
    - tokens_limite: 100000
    - costo_acumulado_usd: 13.50
    - llamadas_totales: 156
    - ultimo_reset: "2025-10-01T00:00:00Z"
    - plan_activo: "profesional"
  Ejemplo: ai:tokens:user_123:2025-10

# ========================================
# 11. CACHÉ DE CONFIGURACIONES (NUEVO)
# ========================================
config:{servicio}:{clave}
  Tipo: String
  TTL: 3600 (1 hora)
  Valor: valor de configuración
  Ejemplos:
    - config:promptads:max_campaigns_per_user: "50"
    - config:ai:default_model: "gpt-4-turbo"
    - config:etl:intervalo_minutos: "11"

# ========================================
# 12. COLA DE TRABAJOS ASÍNCRONOS (NUEVO)
# ========================================
queue:jobs:{tipo_trabajo}
  Tipo: List
  TTL: none (persistente hasta procesado)
  Valores: IDs de trabajos pendientes
  Ejemplo: queue:jobs:generacion_contenido

job:{job_id}
  Tipo: Hash
  TTL: 86400 (24 horas después de completado)
  Campos:
    - tipo: "generacion_imagenes"
    - estado: "pendiente|procesando|completado|error"
    - parametros: '{...}'
    - resultado: '{...}'
    - created_at: "2025-10-22T10:00:00Z"
    - started_at: "2025-10-22T10:01:00Z"
    - completed_at: "2025-10-22T10:05:00Z"
    - intentos: 1
    - max_intentos: 3
  Ejemplo: job:job_abc123

# ========================================
# 13. BLOQUEOS DISTRIBUIDOS (NUEVO)
# ========================================
lock:{recurso}:{id}
  Tipo: String
  TTL: 30 (30 segundos)
  Valor: "worker_id_12345"
  Uso: Evitar condiciones de carrera en ETL/procesamiento
  Ejemplo: lock:etl:promptads_campaigns

# ========================================
# REQUISITOS DE RENDIMIENTO (del documento)
# ========================================
# ✅ Tiempo de respuesta: < 400ms (cacheo reduce a ~5-50ms)
# ✅ Conexiones simultáneas: 5000+ campañas activas
# ✅ 300+ usuarios concurrentes
# ✅ 100,000 operaciones/minuto (horario pico)
# ✅ 300 procesos background/minuto (fuera horario)
# ========================================

# ========================================
# ESTRATEGIA DE INVALIDACIÓN DE CACHÉ
# ========================================
# 1. Invalidación por TTL: Mayoría de casos
# 2. Invalidación manual: 
#    - DEL api:resultados:*  (cuando API cambia)
#    - DEL estadisticas:campana:{id}:* (cuando se actualiza campaña)
# 3. Invalidación por eventos:
#    - Publicar mensaje en canal Redis cuando hay cambios críticos
# ========================================

# ========================================
# PATRONES DE ACCESO COMUNES
# ========================================
# Lectura:
#   1. GET contenido:busqueda:{hash}
#   2. Si no existe: Query MongoDB → SET con TTL
#   3. Retornar resultado

# Escritura con invalidación:
#   1. UPDATE en base de datos principal
#   2. DEL cache relacionado
#   3. Próxima lectura regenerará caché

# Rate limiting:
#   1. INCR ratelimit:service:user:minute
#   2. Si > límite: rechazar request
#   3. TTL automático limpia contador
# ========================================

# ========================================
# MONITOREO Y ALERTAS
# ========================================
# Métricas a monitorear:
# - Hit rate: HGET api:stats:* successful_calls / total_calls
# - Latencia promedio: HGET api:stats:* avg_response_time_ms
# - Uso de memoria: INFO memory
# - Claves expiradas: INFO stats (expired_keys)
# - Rate limit violations: Contadores de rechazos
# ========================================

# ========================================
# EJEMPLO DE FLUJO COMPLETO
# ========================================
# Usuario solicita generar contenido:
# 1. Check ratelimit:openai:user_123:minute < 60
# 2. Check ai:tokens:user_123:2025-10 < límite plan
# 3. Hash del prompt → ai:generacion:gpt4:{hash}
# 4. Si existe en caché: retornar (ahorro tokens/costo)
# 5. Si no existe: llamar OpenAI
# 6. Guardar resultado en caché
# 7. HINCRBY ai:tokens:user_123:2025-10 tokens_usados {cantidad}
# 8. HINCRBY api:stats:openai total_calls 1
# 9. Retornar al usuario
# ========================================

# FIN DEL DISEÑO REDIS