# Diseño de Base de Datos Redis Cache para PromptSales
# Versión: 4.0 - Revisado según requisitos del profesor
# Fecha: 2025-11-03

# ========================================
# Diseño de Base de Datos Redis Cache - PromptSales
# Versión: Simplificada (≈10 minutos de diseño)
# ========================================

# ========================================
# 1. CACHÉ DE LLAMADAS A APIs/MCP SERVERS
# ========================================
# Propósito: Reducir llamadas repetidas a servicios externos
# Beneficio: Ahorro de costos y tiempo de respuesta < 400ms

api:call:{service}:{method}:{hash_params}
  Tipo: String (JSON)
  TTL: 3600 (1 hora)
  Valor: {
    "response": {...},
    "timestamp": "2025-10-22T10:30:00Z",
    "status": 200
  }
  Ejemplo: api:call:openai:generateImage:abc123

mcp:call:{server}:{tool}:{hash_params}
  Tipo: String (JSON)
  TTL: 3600 (1 hora)
  Valor: {
    "result": [...],
    "timestamp": "2025-10-22T10:30:00Z"
  }
  Ejemplo: mcp:call:content_server:getContent:def456

# ========================================
# 2. CACHÉ DE GENERACIONES AI (AHORRO DE TOKENS)
# ========================================
# Propósito: Minimizar consumo de tokens reutilizando respuestas
# Beneficio: Reducción de costos y latencia

ai:generation:{model}:{prompt_hash}
  Tipo: String (JSON)
  TTL: 7200 (2 horas)
  Valor: {
    "content": "contenido generado...",
    "tokens_used": 150,
    "cost_usd": 0.003,
    "timestamp": "2025-10-22T10:30:00Z"
  }
  Ejemplo: ai:generation:gpt4:hash_abc123

# ========================================
# 3. RESULTADOS DE BÚSQUEDA VECTORIAL (MongoDB)
# ========================================
# Propósito: Cachear búsquedas de imágenes en colección MongoDB
# Beneficio: Evitar queries vectoriales costosas

content:search:{description_hash}
  Tipo: String (JSON)
  TTL: 3600 (1 hora)
  Valor: {
    "images": [
      {
        "id": "ObjectId(...)",
        "url": "https://cdn.example.com/img.jpg",
        "hashtags": ["#marketing", "#producto"],
        "score": 0.95
      }
    ],
    "timestamp": "2025-10-22T10:30:00Z"
  }
  Ejemplo: content:search:hash_mascotas_grooming

# ========================================
# 4. CONTROL DE DELTAS PARA ETL
# ========================================
# Propósito: Registrar última sincronización para ETL cada 11 minutos
# Beneficio: Procesar solo datos modificados (deltas)

etl:last_sync:{database}:{table}
  Tipo: String (JSON)
  TTL: 1320 (22 minutos - 2x ciclo ETL)
  Valor: {
    "last_id": 156789,
    "last_timestamp": "2025-10-22T10:09:00Z",
    "records_processed": 342
  }
  Ejemplo: etl:last_sync:promptads:campaigns

# ========================================
# 5. RATE LIMITING BÁSICO (OPCIONAL)
# ========================================
# Propósito: Evitar sobrecarga de APIs externas
# Beneficio: Cumplir límites de servicios externos

ratelimit:{service}:{user_id}:minute
  Tipo: String (contador)
  TTL: 60 (1 minuto)
  Valor: "45"
  Ejemplo: ratelimit:openai:user_123:minute

# ========================================
# REQUISITOS CUMPLIDOS
# ========================================
# Reducir llamadas a APIs REST y servidores MCP
# Minimizar consumo de tokens en modelos AI
# Aumentar velocidad de respuesta (< 400ms)
# Reutilizar resultados frecuentes
# Soporte para deltas en ETL cada 11 minutos
# ========================================

# ========================================
# ESTRATEGIA DE USO
# ========================================
# Patrón típico:
# 1. Cliente solicita generación de contenido
# 2. Hash del prompt → verificar ai:generation:{hash}
# 3. Si existe: retornar desde caché (5-50ms)
# 4. Si no existe: llamar API → guardar en caché
# 5. Retornar resultado al cliente
# ========================================